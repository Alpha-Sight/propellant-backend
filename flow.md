## 1 — High level flow (one line)
Client → Backend creates credential (DB,PENDING) → Relayer sends issue tx → Contract mints/stores credential and emits event → Relayer reads receipt and writes canonical on‑chain id to DB (ISSUED) → Client requests verify → Relayer sends verify tx → Relayer updates DB to VERIFIED or REJECTED based on receipt.

---

## 2 — Smart contract (what to expect)
- Primary action methods:
  - issueCredential(...) — Creates/stores a credential on‑chain and emits a CredentialIssued event.
  - verifyCredential(id, status, notes) — Marks credential as verified/changes state.
- Event to watch:
  - CredentialIssued(...) — usually indexed args. In receipts observed in this repo:
    - topics[0] = event signature hash
    - topics[1] = credential id (zero-padded hex of a numeric id in your deploys; some deployments use bytes32 instead)
    - topics[2] = subject address (indexed)
    - topics[3] = issuer address (indexed)
- Important: different deployed variants may use `uint256` id or `bytes32` id. The app uses a fallback to read topics[1] when the ABI parse fails.

Permissions:
- Verify can require caller to be an issuer/admin role (DEFAULT_ADMIN_ROLE or ISSUER_ROLE). If the tx reverts with "credential does not exist" or with a permission error, check id and caller role.

---

## 3 — Backend components (repo locations)
- CredentialService (backend logic, create/verify endpoints): `src/module/v1/blockchain/services/credential.service.ts`
- RelayerService (transaction queue, send, receipt processing): `src/module/v1/blockchain/services/relayer.service.ts`
- Credential schema (Mongo fields): `src/module/v1/blockchain/schemas/credential.schema.ts`
- Controller endpoints: `src/module/v1/blockchain/controllers/credential.controller.ts`
- Helper scripts:
  - `scripts/parse-issue-event.js` — parse event/logs from an issue tx (supports multiple shapes)
  - `scripts/set-canonical-id.js` — one‑off script to extract topics[1] and set DB fields

Key DB fields on `credentials` collection
- _id (Mongo ObjectId)
- credentialId (local numeric id generated by service)
- blockchainCredentialId (numeric canonical id when small enough)
- tokenId (hex string when canonical id is bytes32 or large)
- transactionId, transactionHash — relayer transaction references
- verificationStatus — one of PENDING, PENDING_BLOCKCHAIN, ISSUED, VERIFIED, REJECTED
- createdAt, verificationRequestedAt, verifiedAt

---

## 4 — Detailed step-by-step: Mint (issue) flow

1. Client calls backend issue endpoint (example path — adjust to your routes).
   - Example payload (the fields are logged by `CredentialService` in this repo):
     ```json
     {
       "subject": "0xde4Db4a37099c0ECAb59B5DD2d08Ba9775Df3bEd",
       "name": "Another Test Certificate",
       "description": "Testing the fixed credential system",
       "metadataURI": "ipfs://QmTest",
       "credentialType": 1,
       "validUntil": 1787759783,
       "evidenceHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
       "revocable": true
     }
     ```
   - Backend action:
     - Generates a local numeric `credentialId` and creates a Mongo document with status `PENDING` (stored fields shown above).
     - Encodes `issueCredential(...)` call data and calls `RelayerService.queueTransaction(...)` with object like:
       ```json
       {
         "userAddress": "<issuerId>",
         "target": "<contract address>",
         "value": "0",
         "data": "0x...",
         "operation": 0,
         "description": "Issue credential ID <local id>"
       }
       ```
     - Returns to client with DB id and relayer tx id (or queued response).

2. Relayer picks queued tx, sends it to blockchain.
   - Logs `"Transaction sent: <txHash>"`.
   - Waits for the receipt.

3. On receipt (receipt.status === 1):
   - Relayer attempts to parse `CredentialIssued` using ABI.
   - If ABI parse fails, relayer falls back to reading `topics[1]` (this repo added that fallback).
     - If `topics[1]` converts to a small integer, it stores `blockchainCredentialId` = decimal.
     - Otherwise it stores `tokenId` = hex string.
   - Relayer updates the credential doc:
     - `verificationStatus` -> `ISSUED`
     - `blockchainCredentialId` or `tokenId` set to canonical on‑chain id
     - `transactionHash` saved
   - If receipt.status === 0 (revert), relayer updates credential to `REJECTED` and writes revert details.

---

## 5 — Verification flow (what client does and what backend does)

Precondition (important): the credential DB doc must have canonical id (`blockchainCredentialId` or `tokenId`) and `verificationStatus === 'ISSUED'`. If not present, verify should be refused to avoid on‑chain revert due to id mismatch.

1. Client calls verify endpoint:
   - Observed request pattern in repo:
     - POST /api/v1/blockchain/credentials/verify/:mongoId
     - Example body used in testing:
       ```json
       {
         "credentialId": "68add466e1b2d3d31783ce26",    // Mongo id
         "verifierAddress": "0xde4Db4a37099c0ECAb59B5DD2d08Ba9775Df3bEd",
         "notes": "Verified by 0x..."
       }
       ```
   - Backend (`CredentialService.verifyCredential`):
     - Loads credential by Mongo ID or by `credentialId`.
     - Checks readiness:
       - If `verificationStatus !== 'ISSUED'` or canonical id missing -> return NOT_READY error (HTTP 409) and do NOT queue relayer tx. (This prevents the race that caused early failures.)
     - Encodes verification call using the canonical id:
       - If numeric `blockchainCredentialId` exists -> encode `verifyCredential(uint256 id, uint8 status, string notes)`
       - If only `tokenId` (hex) exists -> encode `verifyCredential(bytes32 id, ...)` (the repo can be patched to prefer hex).
     - Updates credential to `PENDING_BLOCKCHAIN`, stores `verificationRequestedAt` and relayer tx id.
     - Calls `RelayerService.queueTransaction(...)` to queue the verify tx.

2. Relayer sends verify tx and waits receipt:
   - On success receipt.status === 1: update credential to `VERIFIED`, set `verifiedAt`, ensure canonical id persisted.
   - On failure receipt.status === 0: update credential to `REJECTED`, write revert reason if available.

---

## 6 — Example requests (copyable)

- Create (issue) — (example endpoint; adapt to your controller route):
```bash
curl -X POST http://localhost:3000/api/v1/blockchain/credentials \
  -H "Content-Type: application/json" \
  -d '{
    "subject":"0xde4Db4a37099c0ECAb59B5DD2d08Ba9775Df3bEd",
    "name":"Another Test Certificate",
    "description":"Testing",
    "metadataURI":"ipfs://QmTest",
    "credentialType":1,
    "validUntil":1787759783,
    "revocable":true
  }'
```

- Verify (wait until `verificationStatus === "ISSUED"` in DB):
```bash
curl -X POST http://localhost:3000/api/v1/blockchain/credentials/verify/68add9273211bdce6b2ccf83 \
  -H "Content-Type: application/json" \
  -d '{"verifierAddress":"0x2Ed32Af34d80ADB200592e7e0bD6a3F761677591","notes":"Verified by relayer"}'
```

- Quick DB check (confirm canonical id):
```bash
node -e "const {MongoClient,ObjectId}=require('mongodb');(async()=>{const c=new MongoClient(process.env.MONGO_URL||'mongodb://localhost:27017/propellantbd');await c.connect();const d=await c.db().collection('credentials').findOne({_id:new ObjectId('68add9273211bdce6b2ccf83')});console.log(d);await c.close();})();"
```

---

## 7 — Error responses and what they mean
- NOT_READY / 409 (recommended behavior): credential not yet ISSUED on chain or canonical id missing — client should wait/poll.
- NOT_FOUND / 404: credential id unknown in DB.
- UNAUTHORIZED / 403: caller lacks role to verify.
- TX_ERROR / 502: relayer failed to send transaction or RPC issues.

Current repo behavior observed:
- Initially the controller wrapped service error objects into a `success:true` body; you should change to return proper HTTP statuses (we prepared a patch earlier). After the patch, clients receive 4xx for NOT_READY.

---

## 8 — Common failure modes (and fixes)
1. Revert "CredentialVerification: credential does not exist"
   - Cause: verify used wrong id (local id vs canonical id) or verify called before the relayer persisted canonical id.
   - Fix: Ensure canonical id present and `verificationStatus === 'ISSUED'` before calling verify. Use server status endpoint or poll DB.

2. Revert due to permission
   - Cause: `tx.from` does not have issuer/admin role.
   - Fix: Grant issuer/admin role to the caller address or send transactions from relayer account with proper role.

3. Receipt parsing fails (no event parsed)
   - Cause: deployed contract uses a different event shape or the event has unexpected indexing.
   - Fix: use `scripts/parse-issue-event.js` to inspect raw logs and adapt parser; code contains fallback to topics[1].

4. Race between relayer write and client verify
   - Fixes:
     - Server-side: refuse verify until canonical id present (recommended immediate fix).
     - Client-side: poll status or wait for `ISSUED` signal.
     - Add an explicit status endpoint or emit websocket events when relayer persists canonical id.

---

## 9 — Tools & scripts to help (how to use)
- Parse issue event:
```bash
BLOCKCHAIN_RPC_URL="https://rpc.sepolia-api.lisk.com" \
CREDENTIAL_VERIFICATION_MODULE_ADDRESS="0x700fe28..." \
ISSUE_TX="0xf4b4f4..." \
node scripts/parse-issue-event.js
```
- Set canonical id (one‑off DB fix):
```bash
MONGO_URL="mongodb://localhost:27017/propellantbd" \
BLOCKCHAIN_RPC_URL="https://rpc.sepolia-api.lisk.com" \
CREDENTIAL_VERIFICATION_MODULE_ADDRESS="0x700fe28..." \
ISSUE_TX="0xf4b4f4..." \
node scripts/set-canonical-id.js
```
These scripts are in scripts.

- Inspect a transaction receipt via node/ethers:
```bash
node -e "const { ethers } = require('ethers');(async()=>{const p=new ethers.JsonRpcProvider('https://rpc.sepolia-api.lisk.com');console.log(await p.getTransactionReceipt('0xf4b4f4...'));})();"
```

---

## 10 — Recommendations & next improvements
- Enforce readiness: `verify` endpoint should return 409 if credential not ISSUED or no canonical id. (We can patch this now.)
- Add `GET /api/v1/blockchain/credentials/:id/status` returning:
  ```json
  { "verificationStatus": "ISSUED", "blockchainCredentialId": 11, "tokenId": null }
  ```
  — client polls this to know when to call verify.
- Make relayer update DB atomically and emit a notification (websocket, webhook) when canonical id persists.
- Support both `uint256` and `bytes32` id encoding in `CredentialService.verifyCredential` (prefer tokenId if present).
- Add CI or unit tests for the relayer receipt parsing for both event shapes.

---

## 11 — Quick postmortem summary (for your team)
- Root cause of earlier failure: race + id shape mismatch. Backend used a locally generated id before relayer persisted on‑chain canonical id; contract had the credential stored under different canonical key → verify reverted with "credential does not exist".
- Fixes applied:
  - Relayer: parse issue event and fallback to topics[1], persist canonical id.
  - DB: one‑off script to patch existing credentials.
  - Controller/service: added guards to prevent queuing verify until DB has ISSUED + canonical id (recommended behavior).
- Result: subsequent issue and verify txs succeeded when verify used persisted canonical id.

---



